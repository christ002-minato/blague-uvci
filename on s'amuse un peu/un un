Parfait ğŸ‘
Donc on a dÃ©jÃ  **posts** (comme des *cards* Trello) et **categories** (comme des *lists* Trello).
ğŸ‘‰ Maintenant on ajoute **commentaires** (comme des *activity* ou *discussions* sous chaque carte).

Je vais te donner une **vue Vue3** + un **store CRUD** pour les commentaires, avec la mÃªme logique que ton `usePostStore`, mais adaptÃ©e au format *Trello-like*.

---

# ğŸ”¹ Structure

* **CatÃ©gorie** â†’ regroupe des posts (Ã©quivaut Ã  une *liste* Trello).
* **Post** â†’ une carte, peut avoir plusieurs commentaires.
* **Commentaire** â†’ attachÃ© Ã  un post (`postId`).

---

# ğŸ”¹ Vue (Comments.vue)

```vue
<template>
  <div>
    <!-- Section Commentaires -->
    <div class="mt-3">
      <h6 class="fw-bold">ğŸ’¬ Commentaires</h6>

      <!-- Formulaire ajout -->
      <div class="d-flex mb-2">
        <input v-model="newComment" type="text" class="form-control me-2" placeholder="Ã‰crire un commentaire..." />
        <button class="btn btn-primary" @click="addNewComment">Envoyer</button>
      </div>

      <!-- Liste commentaires -->
      <div v-if="commentsByPost.length">
        <div v-for="c in commentsByPost" :key="c.id" class="p-2 mb-2 border rounded bg-light">
          <div class="d-flex justify-content-between align-items-center">
            <span class="small">{{ c.author }} : {{ c.content }}</span>
            <div>
              <button class="btn btn-sm btn-outline-primary me-1" @click="editComment(c)">âœï¸</button>
              <button class="btn btn-sm btn-outline-danger" @click="deleteComment(c.id)">ğŸ—‘ï¸</button>
            </div>
          </div>
        </div>
      </div>
      <p v-else class="text-muted small">Aucun commentaire pour ce post...</p>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from "vue";
import { useCommentStore } from "@/stores/comment";

const props = defineProps({
  postId: { type: Number, required: true }
});

const commentStore = useCommentStore();
const { comments, fetchComments, addComment, updateComment, deleteComment } = commentStore;

const newComment = ref("");

// Charger les commentaires du post
onMounted(() => {
  fetchComments(props.postId);
});

// Filtrer par post
const commentsByPost = computed(() => {
  return comments.value.filter(c => c.postId === props.postId);
});

// Ajouter
const addNewComment = () => {
  if (!newComment.value) return;
  addComment({
    postId: props.postId,
    author: "Moi", // Ã  remplacer plus tard par user connectÃ©
    content: newComment.value
  });
  newComment.value = "";
};

// Modifier
const editComment = (comment) => {
  const newText = prompt("Modifier commentaire :", comment.content);
  if (!newText) return;
  updateComment(comment.id, { content: newText });
};
</script>
```

---

# ğŸ”¹ Store (useCommentStore.js)

```js
// src/stores/comment.js
import { ref } from "vue";
import api from "@/api.js";

export function useCommentStore() {
  const comments = ref([]);

  // RÃ©cupÃ©rer commentaires dâ€™un post
  const fetchComments = async (postId) => {
    try {
      const res = await api.get(`/posts/${postId}/comments`);
      comments.value = comments.value
        .filter(c => c.postId !== postId) // nettoyer anciens
        .concat(res.data.map(c => ({
          id: c.id,
          postId: postId,
          author: c.author,
          content: c.content
        })));
    } catch (err) {
      console.error("Erreur fetch comments:", err);
    }
  };

  // Ajouter
  const addComment = async (data) => {
    try {
      const res = await api.post(`/posts/${data.postId}/comments`, data);
      comments.value.push(res.data);
    } catch (err) {
      console.error("Erreur ajout commentaire:", err.response?.data || err);
    }
  };

  // Modifier
  const updateComment = async (id, data) => {
    try {
      const res = await api.put(`/comments/${id}`, data);
      const index = comments.value.findIndex(c => c.id === id);
      if (index !== -1) comments.value[index] = { ...comments.value[index], ...res.data };
    } catch (err) {
      console.error("Erreur modification:", err.response?.data || err);
    }
  };

  // Supprimer
  const deleteComment = async (id) => {
    try {
      await api.delete(`/comments/${id}`);
      comments.value = comments.value.filter(c => c.id !== id);
    } catch (err) {
      console.error("Erreur suppression:", err.response?.data || err);
    }
  };

  return {
    comments,
    fetchComments,
    addComment,
    updateComment,
    deleteComment
  };
}
```

---

# ğŸ”¹ Logique (faÃ§on Trello API-like)

* **Endpoint imaginÃ©** :

  * `GET /posts/:postId/comments` â†’ liste des commentaires dâ€™un post.
  * `POST /posts/:postId/comments` â†’ ajouter un commentaire.
  * `PUT /comments/:id` â†’ modifier un commentaire.
  * `DELETE /comments/:id` â†’ supprimer un commentaire.

* Chaque **commentaire** contient :

  ```json
  {
    "id": 12,
    "postId": 4,
    "author": "Alice",
    "content": "TrÃ¨s bon post !"
  }
  ```

---

ğŸ‘‰ Ã‡a complÃ¨te ton CRUD posts + catÃ©gories avec un **CRUD commentaires**, comme Trello :

* CatÃ©gories = *listes*
* Posts = *cards*
* Commentaires = *activity* sous une carte

---

Veux-tu que je tâ€™intÃ¨gre Ã§a **directement dans la vue Post** (chaque post affiche ses commentaires en dessous), comme Trello, ou tu prÃ©fÃ¨res garder une vue `Comments.vue` sÃ©parÃ©e ?
