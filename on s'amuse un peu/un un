Parfait 👍
Donc on a déjà **posts** (comme des *cards* Trello) et **categories** (comme des *lists* Trello).
👉 Maintenant on ajoute **commentaires** (comme des *activity* ou *discussions* sous chaque carte).

Je vais te donner une **vue Vue3** + un **store CRUD** pour les commentaires, avec la même logique que ton `usePostStore`, mais adaptée au format *Trello-like*.

---

# 🔹 Structure

* **Catégorie** → regroupe des posts (équivaut à une *liste* Trello).
* **Post** → une carte, peut avoir plusieurs commentaires.
* **Commentaire** → attaché à un post (`postId`).

---

# 🔹 Vue (Comments.vue)

```vue
<template>
  <div>
    <!-- Section Commentaires -->
    <div class="mt-3">
      <h6 class="fw-bold">💬 Commentaires</h6>

      <!-- Formulaire ajout -->
      <div class="d-flex mb-2">
        <input v-model="newComment" type="text" class="form-control me-2" placeholder="Écrire un commentaire..." />
        <button class="btn btn-primary" @click="addNewComment">Envoyer</button>
      </div>

      <!-- Liste commentaires -->
      <div v-if="commentsByPost.length">
        <div v-for="c in commentsByPost" :key="c.id" class="p-2 mb-2 border rounded bg-light">
          <div class="d-flex justify-content-between align-items-center">
            <span class="small">{{ c.author }} : {{ c.content }}</span>
            <div>
              <button class="btn btn-sm btn-outline-primary me-1" @click="editComment(c)">✏️</button>
              <button class="btn btn-sm btn-outline-danger" @click="deleteComment(c.id)">🗑️</button>
            </div>
          </div>
        </div>
      </div>
      <p v-else class="text-muted small">Aucun commentaire pour ce post...</p>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from "vue";
import { useCommentStore } from "@/stores/comment";

const props = defineProps({
  postId: { type: Number, required: true }
});

const commentStore = useCommentStore();
const { comments, fetchComments, addComment, updateComment, deleteComment } = commentStore;

const newComment = ref("");

// Charger les commentaires du post
onMounted(() => {
  fetchComments(props.postId);
});

// Filtrer par post
const commentsByPost = computed(() => {
  return comments.value.filter(c => c.postId === props.postId);
});

// Ajouter
const addNewComment = () => {
  if (!newComment.value) return;
  addComment({
    postId: props.postId,
    author: "Moi", // à remplacer plus tard par user connecté
    content: newComment.value
  });
  newComment.value = "";
};

// Modifier
const editComment = (comment) => {
  const newText = prompt("Modifier commentaire :", comment.content);
  if (!newText) return;
  updateComment(comment.id, { content: newText });
};
</script>
```

---

# 🔹 Store (useCommentStore.js)

```js
// src/stores/comment.js
import { ref } from "vue";
import api from "@/api.js";

export function useCommentStore() {
  const comments = ref([]);

  // Récupérer commentaires d’un post
  const fetchComments = async (postId) => {
    try {
      const res = await api.get(`/posts/${postId}/comments`);
      comments.value = comments.value
        .filter(c => c.postId !== postId) // nettoyer anciens
        .concat(res.data.map(c => ({
          id: c.id,
          postId: postId,
          author: c.author,
          content: c.content
        })));
    } catch (err) {
      console.error("Erreur fetch comments:", err);
    }
  };

  // Ajouter
  const addComment = async (data) => {
    try {
      const res = await api.post(`/posts/${data.postId}/comments`, data);
      comments.value.push(res.data);
    } catch (err) {
      console.error("Erreur ajout commentaire:", err.response?.data || err);
    }
  };

  // Modifier
  const updateComment = async (id, data) => {
    try {
      const res = await api.put(`/comments/${id}`, data);
      const index = comments.value.findIndex(c => c.id === id);
      if (index !== -1) comments.value[index] = { ...comments.value[index], ...res.data };
    } catch (err) {
      console.error("Erreur modification:", err.response?.data || err);
    }
  };

  // Supprimer
  const deleteComment = async (id) => {
    try {
      await api.delete(`/comments/${id}`);
      comments.value = comments.value.filter(c => c.id !== id);
    } catch (err) {
      console.error("Erreur suppression:", err.response?.data || err);
    }
  };

  return {
    comments,
    fetchComments,
    addComment,
    updateComment,
    deleteComment
  };
}
```

---

# 🔹 Logique (façon Trello API-like)

* **Endpoint imaginé** :

  * `GET /posts/:postId/comments` → liste des commentaires d’un post.
  * `POST /posts/:postId/comments` → ajouter un commentaire.
  * `PUT /comments/:id` → modifier un commentaire.
  * `DELETE /comments/:id` → supprimer un commentaire.

* Chaque **commentaire** contient :

  ```json
  {
    "id": 12,
    "postId": 4,
    "author": "Alice",
    "content": "Très bon post !"
  }
  ```

---

👉 Ça complète ton CRUD posts + catégories avec un **CRUD commentaires**, comme Trello :

* Catégories = *listes*
* Posts = *cards*
* Commentaires = *activity* sous une carte

---

Veux-tu que je t’intègre ça **directement dans la vue Post** (chaque post affiche ses commentaires en dessous), comme Trello, ou tu préfères garder une vue `Comments.vue` séparée ?
